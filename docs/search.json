[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\nIntroduction to single-cell RNA-seq\n\n\n\nAudience\nComputational skills required\nDuration\n\n\n\n\nBiologists\nIntroduction to R\n3-session online workshop (~7.5 hours of trainer-led time)\n\n\n\n\nDescription\nThis repository has teaching materials for a hands-on Introduction to single-cell RNA-seq workshop. This workshop will instruct participants on how to design a single-cell RNA-seq experiment, and how to efficiently manage and analyze the data starting from count matrices. This will be a hands-on workshop in which we will focus on using the Seurat package using R/RStudio. Working knowledge of R is required or completion of the Introduction to R workshop.\nNote for Trainers: Please note that the schedule linked below assumes that learners will spend between 3-4 hours on reading through, and completing exercises from selected lessons between classes. The online component of the workshop focuses on more exercises and discussion/Q & A.\n\n\n\n\n\n\nNote\n\n\n\nThese materials were developed for a trainer-led workshop, but are also amenable to self-guided learning.\n\n\n\n\nLearning Objectives\n\nDescribe best practices for designing a single-cell RNA-seq experiment\nDescribe steps in a single-cell RNA-seq analysis workflow\nUse Seurat and associated tools to perform analysis of single-cell expression data, including data filtering, QC, integration, clustering, and marker identification\nUnderstand practical considerations for performing scRNA-seq, rather than in-depth exploration of algorithm theory\n\n\n\nLessons\n\nWorkshop schedule (trainer-led learning)\nSelf-learning\n\n\n\nInstallation Requirements\n\nApplications\nDownload the most recent versions of R and RStudio for your laptop:\n\nR (version 4.0.0 or above)\nRStudio\n\n\n\nPackages for R\n\n\n\n\n\n\nNotes\n\n\n\nNote 1: Install the packages in the order listed below.\nNote 2:  All the package names listed below are case sensitive!\nNote 3: If you have a Mac with an M1 chip, download and install this tool before intalling your packages: https://mac.r-project.org/tools/gfortran-12.2-universal.pkg\nNote 4: At any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take quite a bit of time to run, so please account for that before you start with these installations.\nNote 5: If you see a message in your console along the lines of “binary version available but the source version is later”, followed by a question, “Do you want to install from sources the package which needs compilation? y/n”, type n for no, and hit enter.\n\n\n(1) Install the 4 packages listed below from Bioconductor using the the BiocManager::install() function.\n\nAnnotationHub\nensembldb\nmulttest\nglmGamPoi\n\nPlease install them one-by-one as follows:\n\nBiocManager::install(\"AnnotationHub\")\nBiocManager::install(\"ensembldb\")\n& so on ...\n\n(2) Install the 8 packages listed below from CRAN using the install.packages() function.\n\ntidyverse\nMatrix\nRCurl\nscales\ncowplot\nBiocManager\nSeurat\nmetap\nreshape2\nplyr\n\nPlease install them one-by-one as follows:\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"Matrix\")\ninstall.packages(\"RCurl\")\n& so on ...\n\n(3) Finally, please check that all the packages were installed successfully by loading them one at a time using the library() function.\n\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(RCurl)\nlibrary(scales)\nlibrary(cowplot)\nlibrary(metap)\nlibrary(reshape2)\nlibrary(plyr)\nlibrary(AnnotationHub)\nlibrary(ensembldb)\nlibrary(multtest)\nlibrary(glmGamPoi)\n\n(4) Once all packages have been loaded, run sessionInfo().\n\nsessionInfo()\n\n\n\n\n\nCitation\nTo cite material from this course in your publications, please use:\n\n\n\n\n\n\nCitation\n\n\n\nMary Piper, Meeta Mistry, Jihe Liu, William Gammerdinger, & Radhika Khetani. (2022, January 6). hbctraining/scRNA-seq_online: scRNA-seq Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826256.\n\n\nA lot of time and effort went into the preparation of these materials. Citations help us understand the needs of the community, gain recognition for our work, and attract further funding to support our teaching activities. Thank you for citing this material if it helped you in your data analysis."
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html",
    "href": "lessons/03_SC_quality_control-setup.html",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "",
    "text": "Approximate time: 90 minutes"
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#learning-objectives",
    "href": "lessons/03_SC_quality_control-setup.html#learning-objectives",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDemonstrate how to import data and set up project for upcoming quality control analysis."
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#exploring-the-example-dataset",
    "href": "lessons/03_SC_quality_control-setup.html#exploring-the-example-dataset",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Exploring the example dataset",
    "text": "Exploring the example dataset\nFor this workshop we will be working with a single-cell RNA-seq dataset which is part of a larger study from Kang et al, 2017. In this paper, the authors present a computational algorithm that harnesses genetic variation (eQTL) to determine the genetic identity of each droplet containing a single cell (singlet) and identify droplets containing two cells from different individuals (doublets).\nThe data used to test their algorithm is comprised of pooled Peripheral Blood Mononuclear Cells (PBMCs) taken from eight lupus patients, split into control and interferon beta-treated (stimulated) conditions.\n\nImage credit: Kang et al, 2017\n\nRaw data\nThis dataset is available on GEO (GSE96583), however the available counts matrix lacked mitochondrial reads, so we downloaded the BAM files from the SRA (SRP102802). These BAM files were converted back to FASTQ files, then run through Cell Ranger to obtain the count data that we will be using.\n\n\n\n\n\n\nNote\n\n\n\nThe count data for this dataset is also freely available from 10X Genomics and is used in the Seurat tutorial.\n\n\n\n\nMetadata\nIn addition to the raw data, we also need to collect information about the data; this is known as metadata. There is often a temptation to just start exploring the data, but it is not very meaningful if we know nothing about the samples that this data originated from.\nSome relevant metadata for our dataset is provided below:\n\nThe libraries were prepared using 10X Genomics version 2 chemistry\nThe samples were sequenced on the Illumina NextSeq 500\nPBMC samples from eight individual lupus patients were separated into two aliquots each.\n\nOne aliquot of PBMCs was activated by 100 U/mL of recombinant IFN-β for 6 hours.\nThe second aliquot was left untreated.\nAfter 6 hours, the eight samples for each condition were pooled together in two final pools (stimulated cells and control cells). We will be working with these two, pooled samples. (We did not demultiplex the samples because SNP genotype information was used to demultiplex in the paper and the barcodes/sample IDs were not readily available for this data. Generally, you would demultiplex and perform QC on each individual sample rather than pooling the samples.)\n\n12,138 and 12,167 cells were identified (after removing doublets) for control and stimulated pooled samples, respectively.\nSince the samples are PBMCs, we will expect immune cells, such as:\n\nB cells\nT cells\nNK cells\nmonocytes\nmacrophages\npossibly megakaryocytes\n\n\nIt is recommended that you have some expectation regarding the cell types you expect to see in a dataset prior to performing the QC. This will inform you if you have any cell types with low complexity (lots of transcripts from a few genes) or cells with higher levels of mitochondrial expression. This will enable us to account for these biological factors during the analysis workflow.\nNone of the above cell types are expected to be low complexity or anticipated to have high mitochondrial content."
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#set-up",
    "href": "lessons/03_SC_quality_control-setup.html#set-up",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Set up",
    "text": "Set up\nFor this workshop, we will be working within an RStudio project. In order to follow along you should have downloaded the R project.\n\n\n\n\n\n\nImportant\n\n\n\nIf you haven’t done this already, the project can be accessed using this link.\n\n\nOnce downloaded, you should see a file called single_cell_rnaseq.zip on your computer (likely, in your Downloads folder).\n\nUnzip this file. It will result in a folder of the same name.\nMove the folder to the location on your computer where you would like to perform the analysis.\nOpen up the folder. The contents will look like the screenshot below.\nLocate the .Rproj file and double-click on it. This will open up RStudio with the “single_cell_rnaseq” project loaded."
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#project-organization",
    "href": "lessons/03_SC_quality_control-setup.html#project-organization",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Project organization",
    "text": "Project organization\nOne of the most important parts of research that involves large amounts of data, is how best to manage it. We tend to prioritize the analysis, but there are many other important aspects of data management that are often overlooked in the excitement to get a first look at new data. The HMS Data Management Working Group, discusses in-depth some things to consider beyond the data creation and analysis.\nOne important aspect of data management is organization. For each experiment you work on and analyze data for, it is considered best practice to get organized by creating a planned storage space (directory structure). We will do that for our single-cell analysis.\nLook inside your project space and you will find that a directory structure has been setup for you:\n\nsingle_cell_rnaseq/\n├── data\n├── results\n└── figures\n\n\n\n\n\n\n\nNOTE FOR WINDOWS OS users\n\n\n\nWhen you open the project folder after unzipping, please check if you have a data folder with a sub folder also called data. If this is the case, please move all the files from the subfolder into the parent data folder.\n\n\n\nNew script\nNext, open a new Rscript file, and start with some comments to indicate what this file is going to contain:\n\n# July/August 2021\n# HBC single-cell RNA-seq workshop\n\n# Single-cell RNA-seq analysis - QC\n\nSave the Rscript as quality_control.R. Your working directory should look something like this:\n\n\n\nLoading libraries\nNow, we can load the necessary libraries:\n\n# Load libraries\nlibrary(SingleCellExperiment)\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(Matrix)\nlibrary(scales)\nlibrary(cowplot)\nlibrary(RCurl)"
  },
  {
    "objectID": "lessons/03_SC_quality_control-setup.html#loading-single-cell-rna-seq-count-data",
    "href": "lessons/03_SC_quality_control-setup.html#loading-single-cell-rna-seq-count-data",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Loading single-cell RNA-seq count data",
    "text": "Loading single-cell RNA-seq count data\nRegardless of the technology or pipeline used to process your raw single-cell RNA-seq sequence data, the output with quantified expression will generally be the same. That is, for each individual sample you will have the following three files:\n\nA file with the cell IDs, representing all cells quantified\nA file with the gene IDs, representing all genes quantified\nA matrix of counts per gene for every cell\n\nWe can explore these files by clicking the data/ctrl_raw_feature_bc_matrix folder:\n\n1. barcodes.tsv\nThis is a text file which contains all cellular barcodes present for that sample. Barcodes are listed in the order of data presented in the matrix file (i.e. these are the column names).\n\n\n\n2. features.tsv\nThis is a text file which contains the identifiers of the quantified genes. The source of the identifier can vary depending on what reference (i.e. Ensembl, NCBI, UCSC) you use in the quantification methods, but most often these are official gene symbols. The order of these genes corresponds to the order of the rows in the matrix file (i.e. these are the row names).\n\n\n\n3. matrix.mtx\nThis is a text file which contains a matrix of count values. The rows are associated with the gene IDs above and columns correspond to the cellular barcodes. Note that there are many zero values in this matrix.\n\nLoading this data into R requires us to use functions that allow us to efficiently combine these three files into a single count matrix. However, instead of creating a regular matrix data structure, the functions we will use create a sparse matrix to reduce the amount of memory (RAM), processing capacity (CPU) and storage required to work with our huge count matrix.\nDifferent methods for reading in data include:\n\nreadMM(): This function is from the Matrix package and will convert our standard matrix into a sparse matrix. The features.tsv file and barcodes.tsv must first be individually loaded into R and then they can be combined. For specific code and instructions on how to do this please see these additional material.\nRead10X(): This function is from the Seurat package and will use the Cell Ranger output directory as input, directly. With this method individual files do not need to be loaded in, instead the function will load and combine them into a sparse matrix. We will be using this function to load in our data!\n\n\n\nReading in a single sample\nAfter processing 10X data using its proprietary software Cell Ranger, you will have an outs directory (always). Within this directory you will find a number of different files including the files listed below:\n\nweb_summary.html: report that explores different QC metrics, including the mapping metrics, filtering thresholds, estimated number of cells after filtering, and information on the number of reads and genes per cell after filtering.\nBAM alignment files: files used for visualization of the mapped reads and for re-creation of FASTQ files, if needed\nfiltered_feature_bc_matrix: folder containing all files needed to construct the count matrix using data filtered by Cell Ranger\nraw_feature_bc_matrix: folder containing all files needed to construct the count matrix using the raw unfiltered data\n\nWhile Cell Ranger performs filtering on the expression counts (see note below), we wish to perform our own QC and filtering because we want to account for the biology of our experiment/biological system. Given this we are only interested in the raw_feature_bc_matrix folder in the Cell Ranger output.\n\n\n\n\n\n\nNote\n\n\n\nWhy do we not use the filtered_feature_bc_matrix folder?** The filtered_feature_bc_matrix uses internal filtering criteria by Cell Ranger, and we do not have control of what cells to keep or abandon._\nThe filtering performed by Cell Ranger when generating the filtered_feature_bc_matrix is often good; however, sometimes data can be of very high quality and the Cell Ranger filtering process can remove high quality cells. In addition, it is generally preferable to explore your own data while taking into account the biology of the experiment for applying thresholds during filtering. For example, if you expect a particular cell type in your dataset to be smaller and/or not as transcriptionally active as other cell types in your dataset, these cells have the potential to be filtered out. However, with Cell Ranger v3 they have tried to account for cells of different sizes (for example, tumor vs infiltrating lymphocytes), and now may not filter as many low quality cells as needed.\n\n\nIf we had a single sample, we could generate the count matrix and then subsequently create a Seurat object:\n\n\n\n\n\n\nThe seurat object\n\n\n\nThe Seurat object is a custom list-like object that has well-defined spaces to store specific information/data. You can find more information about the slots in the Seurat object at this link.\n\n\n\n# How to read in 10X data for a single sample (output is a sparse matrix)\nctrl_counts &lt;- Read10X(data.dir = \"../data/ctrl_raw_feature_bc_matrix\")\n\n# Turn count matrix into a Seurat object (output is a Seurat object)\nctrl &lt;- CreateSeuratObject(counts = ctrl_counts,\n                           min.features = 100)\nctrl\n\nAn object of class Seurat \n33538 features across 15688 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 1 layer present: counts\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe min.features argument specifies the minimum number of genes that need to be detected per cell. This argument will filter out poor quality cells that likely just have random barcodes encapsulated without any cell present. Usually, cells with less than 100 genes detected are not considered for analysis.\n\n\nSeurat automatically creates some metadata for each of the cells when you use the Read10X() function to read in data. This information is stored in the meta.data slot within the Seurat object.\n\n# Explore the metadata\nhead(ctrl@meta.data)\n\n                    orig.ident nCount_RNA nFeature_RNA\nAAACATACAATGCC-1 SeuratProject       2344          874\nAAACATACATTTCC-1 SeuratProject       3125          896\nAAACATACCAGAAA-1 SeuratProject       2578          725\nAAACATACCAGCTA-1 SeuratProject       3261          979\nAAACATACCATGCA-1 SeuratProject        746          362\nAAACATACCTCGCT-1 SeuratProject       3519          866\n\n\nWhat do the columns of metadata mean?\n\norig.ident: this often contains the sample identity if known, but will default to “SeuratProject”\nnCount_RNA: number of UMIs per cell\nnFeature_RNA: number of genes detected per cell\n\n\n\nReading in multiple samples with a for loop\nIn practice, you will likely have several samples that you will need to read in data for, and that can get tedious and error-prone if you do it one at a time. So, to make the data import into R more efficient we can use a for loop, which will iterate over a series of commands for each of the inputs given and create seurat objects for each of our samples.\nIn R, the for loop has the following structure/syntax:\n\n## DO NOT RUN\n\nfor (variable in input){\n    command1\n    command2\n    command3\n}\n\nToday we will use it to iterate over the two sample folders and execute two commands for each sample as we did above for a single sample -\n\nRead in the count data (Read10X()) and\nCreate the Seurat objects from the read in data (CreateSeuratObject())\n\nGo ahead and copy and paste the code below into your script and then run it.\n\nsample_names &lt;- c(\"ctrl\", \"stim\")\n\n# Empty list to populate seurat object for each sample\nlist_seurat &lt;- list()\n\nfor (sample in sample_names) {\n    # Path to data directory\n    data_dir &lt;- paste0(\"../data/\", sample, \"_raw_feature_bc_matrix\")\n\n    # Create a Seurat object for each sample\n    seurat_data &lt;- Read10X(data.dir = data_dir)\n    seurat_obj &lt;- CreateSeuratObject(counts = seurat_data,\n                                      min.features = 100,\n                                      project = sample)\n\n    # Save seurat object to list\n    list_seurat[[sample]] &lt;- seurat_obj\n}\n\nLet’s break down the for loop and go over the different lines of code:\n\n\n\n\n\n\nBreaking down the for loop\n\n\n\n\nStep 1: Specify inputs\nFor this dataset, we have two samples and two associated folders that we would like to use as input to create the two Seurat objects:\n\nctrl_raw_feature_bc_matrix\nstim_raw_feature_bc_matrix\n\nWe can specify these sample names in the input part for our for loop as elements of a vector using c(). We are assigning these to a variable and we can call that variable anything we would like (try to give it a name that makes sense). In this example, we called the variable sample.\nDuring the execution of the above loop, sample will first contain the value “ctrl”, run through the commands all the way through to storing the seurat object as a list. Next, it will contain the value “stim” and once again run through all the commands. If you had 15 folders as input, instead of 2, the above code will run through 15 times, for each of your data folders.\nTo start, let us test out what happens if we print out what sample looks like and the associated data_dir path we specify.\n\nsample_names &lt;- c(\"ctrl\", \"stim\")\n# Empty list to populate seurat object for each sample\nlist_seurat &lt;- list()\n\n# Create each individual Seurat object\nfor (sample in sample_names) {\n    print(sample)\n    # Path to data directory\n    data_dir &lt;- paste0(\"../data/\", sample, \"_raw_feature_bc_matrix\")\n    print(data_dir)\n}\n\n\n\nStep 2: Read in data for the input\nWe can continue our for loop by adding a line to read in data with Read10X():\n\n## DO NOT RUN\n        seurat_data &lt;- Read10X(data.dir = data_dir)\n\n\n\nStep 3: Create Seurat object from the 10X count data\nNow, we can create the Seurat object by using the CreateSeuratObject() nction, adding in the argument project, where we can add the sample name.\n\n## DO NOT RUN\n        seurat_obj &lt;- CreateSeuratObject(counts = seurat_data, \n                                         min.features = 100, \n                                         project = sample)        \n\n\n\nStep 4: Assign Seurat object to a new variable based on sample\nThe last command assignts the Seurat object created (seurat_obj) to the empty list that was initialized before the for loop. In this way, when we iterate and move on to the next sample in our input we will not overwrite the Seurat object created in the previous iteration:\n\n## DO NOT RUN\n        list_seurat[[sample]] &lt;- seurat_obj\n}\n\n\n\n\nNow that we have created both of these objects, let’s take a quick look at the list we just created. We should see that there are two seurat objects in our list that correspond to each sample.\n\nlist_seurat\n\n$ctrl\nAn object of class Seurat \n33538 features across 15688 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 1 layer present: counts\n\n$stim\nAn object of class Seurat \n33538 features across 15756 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 1 layer present: counts\n\n\nNext, we need to merge these objects together into a single Seurat object. This will make it easier to run the QC steps for both sample groups together and enable us to easily compare the data quality for all the samples.\nWe can use the merge() and JoinLayers() functions from the Seurat package to do this:\n\n# Create a merged Seurat object\nmerged_seurat &lt;- merge(x = list_seurat[[\"ctrl\"]], \n                       y = list_seurat[[\"stim\"]], \n                       add.cell.id = c(\"ctrl\", \"stim\"))\n\n# Concatenate the count matrices of both samples together\nmerged_seurat &lt;- JoinLayers(merged_seurat)\nmerged_seurat\n\nAn object of class Seurat \n33538 features across 31444 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 1 layer present: counts\n\n\nBecause the same cell IDs can be used for different samples, we add a sample-specific prefix to each of our cell IDs using the add.cell.id argument.\n\n\n\n\n\n\nWhat if I am merging more than two samples?\n\n\n\nSeurat now has functionality to merge many samples together. You can do this quite easily by adding all sample objects to the y argument in a vector format. An example is provided below:\n\n## DO NOT RUN\n merged_seurat &lt;- merge(x = seurat_list[[1]], \n                        y = seurat_list[[2:length(seurat_list)]],\n                        add.cell.id = names(seurat_list))\n\n\n\nIf we look at the metadata of the merged object we should be able to see the prefixes in the rownames:\n\n# Check that the merged object has the appropriate sample-specific prefixes\nhead(merged_seurat@meta.data)\n\n                      orig.ident nCount_RNA nFeature_RNA\nctrl_AAACATACAATGCC-1       ctrl       2344          874\nctrl_AAACATACATTTCC-1       ctrl       3125          896\nctrl_AAACATACCAGAAA-1       ctrl       2578          725\nctrl_AAACATACCAGCTA-1       ctrl       3261          979\nctrl_AAACATACCATGCA-1       ctrl        746          362\nctrl_AAACATACCTCGCT-1       ctrl       3519          866\n\ntail(merged_seurat@meta.data)\n\n                      orig.ident nCount_RNA nFeature_RNA\nstim_TTTGCATGCGACAT-1       stim        620          295\nstim_TTTGCATGCTAAGC-1       stim       1641          545\nstim_TTTGCATGGGACGA-1       stim       1233          518\nstim_TTTGCATGGTGAGG-1       stim       1084          469\nstim_TTTGCATGGTTTGG-1       stim        818          432\nstim_TTTGCATGTCTTAC-1       stim       1104          438"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html",
    "href": "lessons/04_SC_quality_control.html",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "",
    "text": "Approximate time: 90 minutes"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#learning-objectives",
    "href": "lessons/04_SC_quality_control.html#learning-objectives",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nConstruct quality control metrics and visually evaluate the quality of the data\nApply appropriate filters to remove low quality cells"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#generating-quality-metrics",
    "href": "lessons/04_SC_quality_control.html#generating-quality-metrics",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Generating quality metrics",
    "text": "Generating quality metrics\nWhen data is loaded into Seurat and the initial object is created, there is some basic metadata asssembled for each of the cells in the count matrix. To take a close look at this metadata, let’s view the data frame stored in the meta.data slot of our merged_seurat object:\n\n# Explore merged metadata\nView(merged_seurat@meta.data)\n\n\nThere are three columns of information:\n\norig.ident: this column will contain the sample identity if known. It will default to the value we provided for the project argument when loading in the data\nnCount_RNA: this column represents the number of UMIs per cell\nnFeature_RNA: this column represents the number of genes detected per cell\n\nIn order to create the appropriate plots for the quality control analysis, we need to calculate some additional metrics. These include:\n\nNumber of genes detected per UMI: this metric with give us an idea of the complexity of our dataset (more genes detected per UMI, more complex our data)\nMitochondrial ratio: this metric will give us a percentage of cell reads originating from the mitochondrial genes\n\n\nNovelty score\nThis value is quite easy to calculate, as we take the log10 of the number of genes detected per cell and the log10 of the number of UMIs per cell, then divide the log10 number of genes by the log10 number of UMIs. The novelty score and how it relates to complexity of the RNA species, is described in more detail later in this lesson.\n\n# Add number of genes per UMI for each cell to metadata\nmerged_seurat$log10GenesPerUMI &lt;- log10(merged_seurat$nFeature_RNA) / log10(merged_seurat$nCount_RNA)\n\n\n\nMitochondrial Ratio\nSeurat has a convenient function that allows us to calculate the proportion of transcripts mapping to mitochondrial genes. The PercentageFeatureSet() function takes in a pattern argument and searches through all gene identifiers in the dataset for that pattern. Since we are looking for mitochondrial genes, we are searching any gene identifiers that begin with the pattern “MT-”. For each cell, the function takes the sum of counts across all genes (features) belonging to the “Mt-” set, and then divides by the count sum for all genes (features). This value is multiplied by 100 to obtain a percentage value.\n\n\n\n\n\n\nNote\n\n\n\nFor our analysis, rather than using a percentage value we would prefer to work with the ratio value. As such, we will reverse that last step performed by the function by taking the output value and dividing by 100.\n\n\n\n# Compute percent mito ratio\nmerged_seurat$mitoRatio &lt;- PercentageFeatureSet(object = merged_seurat, pattern = \"^MT-\")\nmerged_seurat$mitoRatio &lt;- merged_seurat@meta.data$mitoRatio / 100\n\n\n\n\n\n\n\nNote\n\n\n\nThe pattern provided (“^MT-”) works for human gene names. You may need to adjust the pattern argument depending on your organism of interest. Additionally, if you weren’t using gene names as the gene ID then this function wouldn’t work as we have used it above as the pattern will not suffice. Since there are caveats to using this function, it is advisable to manually compute this metric. If you are interested, we have code available to compute this metric on your own.\n\n\n\n\nAdditional metadata columns\nWe are a now all set with quality metrics required for assessing our data. However, we would like to include some additional information that would be useful to have in our metadata including cell IDs and condition information.\nWhen we added columns of information to our metadata file above, we simply added it directly to the metadata slot in the Seurat object using the $ operator. We could continue to do so for the next few columns of data, but instead we will extract the dataframe into a separate variable. In this way we can work with the metadata data frame as a seperate entity from the seurat object without the risk of affecting any other data stored inside the object.\nLet’s begin by creating the metadata dataframe by extracting the meta.data slot from the Seurat object:\n\n# Create metadata dataframe\nmetadata &lt;- merged_seurat@meta.data\n\nNext, we’ll add a new column for cell identifiers. This information is currently located in the row names of our metadata dataframe. We will keep the rownames as is and duplicate it into a new column called cells:\n\n# Add cell IDs to metadata\nmetadata$cells &lt;- rownames(metadata)\n\nYou should see that each cell ID has a ctrl_ or stim_ prefix as we had specified when we merged the Seurat objects. We can use this prefix to create a new column indicating which condition each cell is classfied under. We will call this column sample:\n\n# Create sample column\nmetadata$sample &lt;- NA\nmetadata$sample[which(str_detect(metadata$cells, \"^ctrl_\"))] &lt;- \"ctrl\"\nmetadata$sample[which(str_detect(metadata$cells, \"^stim_\"))] &lt;- \"stim\"\n\nAnd finally, we will rename some of the existing columns in our metadata dataframe to be more intuitive:\n\n# Rename columns\nmetadata &lt;- metadata %&gt;%\n        dplyr::rename(seq_folder = orig.ident,\n                      nUMI = nCount_RNA,\n                      nGene = nFeature_RNA)\n\nNow you are all setup with the metrics you need to assess the quality of your data! Your final metadata table will have rows that correspond to each cell, and columns with information about those cells:\n\n\n\nSaving the updated metadata to our Seurat object\nBefore we assess our metrics we are going to save all of the work we have done thus far back into our Seurat object. We can do this by simply assigning the dataframe into the meta.data slot:\n\n# Add metadata back to Seurat object\nmerged_seurat@meta.data &lt;- metadata\n                           \n# Create .RData object to load at any time\nsave(merged_seurat, file=\"../data/merged_filtered_seurat.RData\")"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#assessing-the-quality-metrics",
    "href": "lessons/04_SC_quality_control.html#assessing-the-quality-metrics",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Assessing the quality metrics",
    "text": "Assessing the quality metrics\nNow that we have generated the various metrics to assess, we can explore them with visualizations. We will assess various metrics and then decide on which cells are low quality and should be removed from the analysis:\n\nCell counts\nUMI counts per cell\nGenes detected per cell\nComplexity (novelty score)\nMitochondrial counts ratio\n\n\n\n\n\n\n\nWhat about doublets?\n\n\n\nIn single-cell RNA sequencing experiments, doublets are generated from two cells. They typically arise due to errors in cell sorting or capture, especially in droplet-based protocols involving thousands of cells. Doublets are obviously undesirable when the aim is to characterize populations at the single-cell level. In particular, they can incorrectly suggest the existence of intermediate populations or transitory states that do not actually exist. Thus, it is desirable to remove doublet libraries so that they do not compromise interpretation of the results.\n\n\n\n\n\n\n\n\nWhy aren’t we checking for doublets?\n\n\n\nMany workflows use maximum thresholds for UMIs or genes, with the idea that a much higher number of reads or genes detected indicate multiple cells. While this rationale seems to be intuitive, it is not accurate. Also, many of the tools used to detect doublets tend to get rid of cells with intermediate or continuous phenotypes, although they may work well on datasets with very discrete cell types. Scrublet is a popular tool for doublet detection, but we haven’t adequately benchmarked it yet. Currently, we recommend not including any thresholds at this point in time. When we have identified markers for each of the clusters, we suggest exploring the markers to determine whether the markers apply to more than one cell type.\n\n\n\nCell counts\nThe cell counts are determined by the number of unique cellular barcodes detected. For this experiment, between 12,000 -13,000 cells are expected.\nIn an ideal world, you would expect the number of unique cellular barcodes to correpsond to the number of cells you loaded. However, this is not the case as capture rates of cells are only a proportion of what is loaded. For example, the inDrops cell capture efficiency is higher (70-80%) compared to 10X which is between 50-60%.\n\n\n\n\n\n\nNote\n\n\n\nThe capture efficiency could appear much lower if the cell concentration used for library preparation was not accurate. Cell concentration should NOT be determined by FACS machine or Bioanalyzer (these tools are not accurate for concentration determination), instead use a hemocytometer or automated cell counter for calculation of cell concentration._\n\n\nThe cell numbers can also vary by protocol, producing cell numbers that are much higher than what we loaded. For example, during the inDrops protocol, the cellular barcodes are present in the hydrogels, which are encapsulated in the droplets with a single cell and lysis/reaction mixture. While each hydrogel should have a single cellular barcode associated with it, occasionally a hydrogel can have more than one cellular barcode. Similarly, with the 10X protocol there is a chance of obtaining only a barcoded bead in the emulsion droplet (GEM) and no actual cell. Both of these, in addition to the presence of dying cells can lead to a higher number of cellular barcodes than cells.\n\n# Visualize the number of cell counts per sample\nmetadata %&gt;% \n    ggplot(aes(x=sample, fill=sample)) + \n    geom_bar() +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +\n    theme(plot.title = element_text(hjust=0.5, face=\"bold\")) +\n    ggtitle(\"NCells\")\n\n\n\n\nWe see over 15,000 cells per sample, which is quite a bit more than the 12-13,000 expected. It is clear that we likely have some junk ‘cells’ present.\n\n\nUMI counts (transcripts) per cell\nThe UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply.\n\n# Visualize the number UMIs/transcripts per cell\nmetadata %&gt;% \n    ggplot(aes(color=sample, x=nUMI, fill= sample)) + \n    geom_density(alpha = 0.2) + \n    scale_x_log10() + \n    theme_classic() +\n    ylab(\"Cell density\") +\n    geom_vline(xintercept = 500)\n\n\n\n\nWe can see that majority of our cells in both samples have 1000 UMIs or greater, which is great.\n\n\nGenes detected per cell\nWe have similar expectations for gene detection as for UMI detection, although it may be a bit lower than UMIs. For high quality data, the proportional histogram should contain a single large peak that represents cells that were encapsulated. If we see a small shoulder to the left of the major peak (not present in our data), or a bimodal distribution of the cells, that can indicate a couple of things. It might be that there are a set of cells that failed for some reason. It could also be that there are biologically different types of cells (i.e. quiescent cell populations, less complex cells of interest), and/or one type is much smaller than the other (i.e. cells with high counts may be cells that are larger in size). Therefore, this threshold should be assessed with other metrics that we describe in this lesson.\n\n# Visualize the distribution of genes detected per cell via histogram\nmetadata %&gt;% \n    ggplot(aes(color=sample, x=nGene, fill= sample)) + \n    geom_density(alpha = 0.2) + \n    theme_classic() +\n    scale_x_log10() + \n    geom_vline(xintercept = 300)\n\n\n\n\n\n\nComplexity\nWe can evaluate each cell in terms of how complex the RNA species are by using a measure called the novelty score. The novelty score is computed by taking the ratio of nGenes over nUMI. If there are many captured transcripts (high nUMI) and a low number of genes detected in a cell, this likely means that you only captured a low number of genes and simply sequenced transcripts from those lower number of genes over and over again. These low complexity (low novelty) cells could represent a specific cell type (i.e. red blood cells which lack a typical transcriptome), or could be due to an artifact or contamination. Generally, we expect the novelty score to be above 0.80 for good quality cells.\n\n# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI (novelty score)\nmetadata %&gt;%\n    ggplot(aes(x=log10GenesPerUMI, color = sample, fill=sample)) +\n    geom_density(alpha = 0.2) +\n    theme_classic() +\n    geom_vline(xintercept = 0.8)\n\n\n\n\n\n\nMitochondrial counts ratio\nThis metric can identify whether there is a large amount of mitochondrial contamination from dead or dying cells. We define poor quality samples for mitochondrial counts as cells which surpass the 0.2 mitochondrial ratio mark, unless of course you are expecting this in your sample.\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\nmetadata %&gt;% \n    ggplot(aes(color=sample, x=mitoRatio, fill=sample)) + \n    geom_density(alpha = 0.2) + \n    scale_x_log10() + \n    theme_classic() +\n    geom_vline(xintercept = 0.2)\n\n\n\n\n\n\n\n\n\n\nReads per cell\n\n\n\nThis is another metric that can be useful to explore; however, the workflow used would need to save this information to assess. Generally, with this metric you hope to see all of the samples with peaks in relatively the same location between 10,000 and 100,000 reads per cell.\n\n\n\n\nJoint filtering effects\nConsidering any of these QC metrics in isolation can lead to misinterpretation of cellular signals. For example, cells with a comparatively high fraction of mitochondrial counts may be involved in respiratory processes and may be cells that you would like to keep. Likewise, other metrics can have other biological interpretations. A general rule of thumb when performing QC is to set thresholds for individual metrics to be as permissive as possible, and always consider the joint effects of these metrics. In this way, you reduce the risk of filtering out any viable cell populations.\nTwo metrics that are often evaluated together are the number of UMIs and the number of genes detected per cell. Here, we have plotted the number of genes versus the number of UMIs coloured by the fraction of mitochondrial reads. Jointly visualizing the count and gene thresholds and additionally overlaying the mitochondrial fraction, gives a summarized persepective of the quality per cell.\n\n# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs\nmetadata %&gt;% \n    ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + \n    geom_point() + \n    scale_colour_gradient(low = \"gray90\", high = \"black\") +\n    stat_smooth(method=lm) +\n    scale_x_log10() + \n    scale_y_log10() + \n    theme_classic() +\n    geom_vline(xintercept = 500) +\n    geom_hline(yintercept = 250) +\n    facet_wrap(~sample)\n\n\n\n\nGood cells will generally exhibit both higher number of genes per cell and higher numbers of UMIs (upper right quadrant of the plot). Cells that are poor quality are likely to have low genes and UMIs per cell, and correspond to the data points in the bottom left quadrant of the plot. With this plot we also evaluate the slope of the line, and any scatter of data points in the bottom right hand quadrant of the plot. These cells have a high number of UMIs but only a few number of genes. These could be dying cells, but also could represent a population of a low complexity celltype (i.e red blood cells).\nMitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved. We can see from the plot, that these cells are filtered out by our count and gene number thresholds."
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#filtering",
    "href": "lessons/04_SC_quality_control.html#filtering",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Filtering",
    "text": "Filtering\n\nCell-level filtering\nNow that we have visualized the various metrics, we can decide on the thresholds to apply which will result in the removal of low quality cells. Often the recommendations mentioned earlier are a rough guideline, and the specific experiment needs to inform the exact thresholds chosen. We will use the following thresholds:\n\nnUMI &gt; 500\nnGene &gt; 250\nlog10GenesPerUMI &gt; 0.8\nmitoRatio &lt; 0.2\n\nTo filter, we wil go back to our Seurat object and use the subset() function:\n\n# Filter out low quality cells using selected thresholds - these will change with experiment\nfiltered_seurat &lt;- subset(x = merged_seurat, \n                         subset= (nUMI &gt;= 500) & \n                           (nGene &gt;= 250) & \n                           (log10GenesPerUMI &gt; 0.80) & \n                           (mitoRatio &lt; 0.20))\nfiltered_seurat\n\nAn object of class Seurat \n33538 features across 29629 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 1 layer present: counts\n\n\n\n\nGene-level filtering\nWithin our data we will have many genes with zero counts. These genes can dramatically reduce the average expression for a cell and so we will remove them from our data. We will start by identifying which genes have a zero count in each cell:\n\n# Extract counts\ncounts &lt;- GetAssayData(object = filtered_seurat, layer = \"counts\")\n\n# Output a logical matrix specifying for each gene on whether or not there are more than zero counts per cell\nnonzero &lt;- counts &gt; 0\n\nNow, we will perform some filtering by prevalence. If a gene is only expressed in a handful of cells, it is not particularly meaningful as it still brings down the averages for all other cells it is not expressed in. For our data we choose to keep only genes which are expressed in 10 or more cells. By using this filter, genes which have zero counts in all cells will effectively be removed.\n\n# Sums all TRUE values and returns TRUE if more than 10 TRUE values per gene\nkeep_genes &lt;- Matrix::rowSums(nonzero) &gt;= 10\n\n# Only keeping those genes expressed in more than 10 cells\nfiltered_counts &lt;- counts[keep_genes, ]\n\nFinally, take those filtered counts and create a new Seurat object for downstream analysis.\n\n# Reassign to filtered Seurat object\nfiltered_seurat &lt;- CreateSeuratObject(filtered_counts, meta.data = filtered_seurat@meta.data)\nfiltered_seurat\n\nAn object of class Seurat \n14065 features across 29629 samples within 1 assay \nActive assay: RNA (14065 features, 0 variable features)\n 1 layer present: counts"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#re-assess-qc-metrics",
    "href": "lessons/04_SC_quality_control.html#re-assess-qc-metrics",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Re-assess QC metrics",
    "text": "Re-assess QC metrics\nAfter performing the filtering, it’s recommended to look back over the metrics to make sure that your data matches your expectations and is good for downstream analysis.\n\n\n\n\n\n\n\nExercises\n\n\n\n\nExtract the new metadata from the filtered Seurat object using the code provided below:\n\n\n# Save filtered subset to new metadata\nmetadata_clean &lt;- filtered_seurat@meta.data\n\n\nPerform all of the same QC plots using the filtered data.\nReport the number of cells left for each sample, and comment on whether the number of cells removed is high or low. Can you give reasons why this number is still not ~12K (which is how many cells were loaded for the experiment)?\nAfter filtering for nGene per cell, you should still observe a small shoulder to the right of the main peak. What might this shoulder represent?\nWhen plotting the nGene against nUMI do you observe any data points in the bottom right quadrant of the plot? What can you say about these cells that have been removed?"
  },
  {
    "objectID": "lessons/04_SC_quality_control.html#saving-filtered-cells",
    "href": "lessons/04_SC_quality_control.html#saving-filtered-cells",
    "title": "Single-cell RNA-seq: Quality Control Analysis",
    "section": "Saving filtered cells",
    "text": "Saving filtered cells\nBased on these QC metrics we would identify any failed samples and move forward with our filtered cells. Often we iterate through the QC metrics using different filtering criteria; it is not necessarily a linear process. When satisfied with the filtering criteria, we would save our filtered cell object for clustering and marker identification.\n\n# Create .RData object to load at any time\nsave(filtered_seurat, file=\"../data/seurat_filtered.RData\")\n\n\n\n\n\n\n\nNote\n\n\n\nThe data we are working with is pretty good quality. If you are interested in knowing what ‘bad’ data might look like when performing QC, we have some materials linked here where we explore similar QC metrics of a poor quality sample._"
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html",
    "href": "lessons/02_SC_generation_of_count_matrix.html",
    "title": "Generation of count matrix",
    "section": "",
    "text": "Depending on the library preparation method used, the RNA sequences (also referred to as reads or tags), will be derived either from the 3’ ends (or 5’ ends) of the transcripts (10X Genomics, CEL-seq2, Drop-seq, inDrops) or from full-length transcripts (Smart-seq).\n\nImage credit: Papalexi E and Satija R. Single-cell RNA sequencing to explore immune cell heterogeneity, Nature Reviews Immunology 2018 (https://doi.org/10.1038/nri.2017.76)\nThe choice of method involves the biological question of interest. The following advantages are listed below for the methods:\n\n3’ (or 5’)-end sequencing:\n\nMore accurate quantification through the use of unique molecular identifiers distinguishing biological duplicates from amplification (PCR) duplicates\nLarger number of cells sequenced allows better identity of cell type populations\nCheaper per cell cost\nBest results with &gt; 10,000 cells\n\nFull length sequencing:\n\nDetection of isoform-level differences in expression\nIdentification of allele-specific differences in expression\nDeeper sequencing of a smaller number of cells\nBest for samples with low number of cells\n\n\nMany of the same analysis steps need to occur for 3’-end sequencing as for full-length, but 3’ protocols have been increasing in popularity and consist of a few more steps in the analysis. Therefore, our materials are going to detail the analysis of data from these 3’ protocols with a focus on the droplet-based methods (inDrops, Drop-seq, 10X Genomics)."
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-data---raw-data-to-count-matrix",
    "href": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-data---raw-data-to-count-matrix",
    "title": "Generation of count matrix",
    "section": "",
    "text": "Depending on the library preparation method used, the RNA sequences (also referred to as reads or tags), will be derived either from the 3’ ends (or 5’ ends) of the transcripts (10X Genomics, CEL-seq2, Drop-seq, inDrops) or from full-length transcripts (Smart-seq).\n\nImage credit: Papalexi E and Satija R. Single-cell RNA sequencing to explore immune cell heterogeneity, Nature Reviews Immunology 2018 (https://doi.org/10.1038/nri.2017.76)\nThe choice of method involves the biological question of interest. The following advantages are listed below for the methods:\n\n3’ (or 5’)-end sequencing:\n\nMore accurate quantification through the use of unique molecular identifiers distinguishing biological duplicates from amplification (PCR) duplicates\nLarger number of cells sequenced allows better identity of cell type populations\nCheaper per cell cost\nBest results with &gt; 10,000 cells\n\nFull length sequencing:\n\nDetection of isoform-level differences in expression\nIdentification of allele-specific differences in expression\nDeeper sequencing of a smaller number of cells\nBest for samples with low number of cells\n\n\nMany of the same analysis steps need to occur for 3’-end sequencing as for full-length, but 3’ protocols have been increasing in popularity and consist of a few more steps in the analysis. Therefore, our materials are going to detail the analysis of data from these 3’ protocols with a focus on the droplet-based methods (inDrops, Drop-seq, 10X Genomics)."
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#end-reads-includes-all-droplet-based-methods",
    "href": "lessons/02_SC_generation_of_count_matrix.html#end-reads-includes-all-droplet-based-methods",
    "title": "Generation of count matrix",
    "section": "3’-end reads (includes all droplet-based methods)",
    "text": "3’-end reads (includes all droplet-based methods)\nFor the analysis of scRNA-seq data, it is helpful to understand what information is present in each of the reads and how we use it moving forward through the analysis.\nFor the 3’-end sequencing methods, reads originating from different molecules of the same transcript would have originated only from the 3’ end of the transcripts, so would have a high likelihood of having the same sequence. However, the PCR step during library preparation could also generate read duplicates. To determine whether a read is a biological or technical duplicate, these methods use unique molecular identifiers, or UMIs.\n\nReads with different UMIs mapping to the same transcript were derived from different molecules and are biological duplicates - each read should be counted.\nReads with the same UMI originated from the same molecule and are technical duplicates - the UMIs should be collapsed to be counted as a single read.\nIn image below, the reads for ACTB should be collapsed and counted as a single read, while the reads for ARL1 should each be counted.\n\n\nImage credit: modified from Macosko EZ et al. Highly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets, Cell 2015 (https://doi.org/10.1016/j.cell.2015.05.002)\nSo we know that we need to keep track of the UMIs, but what other information do we need to properly quantify the expression in each gene in each of the cells in our samples? Regardless of droplet method, the following are required for proper quantification at the cellular level:\n\n\nSample index: determines which sample the read originated from (red bottom arrow)\n\nAdded during library preparation - needs to be documented\n\nCellular barcode: determines which cell the read originated from (purple top arrow)\n\nEach library preparation method has a stock of cellular barcodes used during the library preparation\n\nUnique molecular identifier (UMI): determines which transcript molecule the read originated from\n\nThe UMI will be used to collapse PCR duplicates (purple bottom arrow)\n\nSequencing read1: the Read1 sequence (red top arrow)\nSequencing read2: the Read2 sequence (purple bottom arrow)\n\nImage credit: Sarah Boswell, Director of the Single Cell Sequencing Core at HMS"
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-workflow",
    "href": "lessons/02_SC_generation_of_count_matrix.html#single-cell-rna-seq-workflow",
    "title": "Generation of count matrix",
    "section": "Single-cell RNA-seq workflow",
    "text": "Single-cell RNA-seq workflow\nThe scRNA-seq method will determine how to parse the barcodes and UMIs from the sequencing reads. So, although a few of the specific steps will slightly differ, the overall workflow will generally follow the same steps regardless of method. The general workflow is shown below:\n\nImage credit: Luecken, MD and Theis, FJ. Current best practices in single‐cell RNA‐seq analysis: a tutorial, Mol Syst Biol 2019 (doi: https://doi.org/10.15252/msb.20188746)\nThe steps of the workflow are:\n\nGeneration of the count matrix (method-specific steps): formating reads, demultiplexing samples, mapping and quantification\nQuality control of the raw counts: filtering of poor quality cells\nClustering of filtered counts: clustering cells based on similarities in transcriptional activity (cell types = different clusters)\nMarker identification and cluster annotation: identifying gene markers for each cluster and annotating known cell type clusters\nOptional downstream steps\n\nRegardless of the analysis being done, conclusions about a population based on a single sample per condition are not trustworthy. BIOLOGICAL REPLICATES ARE STILL NEEDED! That is, if you want to make conclusions that correspond to the population and not just the single sample."
  },
  {
    "objectID": "lessons/02_SC_generation_of_count_matrix.html#generation-of-count-matrix",
    "href": "lessons/02_SC_generation_of_count_matrix.html#generation-of-count-matrix",
    "title": "Generation of count matrix",
    "section": "Generation of count matrix",
    "text": "Generation of count matrix\nWe are going to start by discussing the first part of this workflow, which is generating the count matrix from the raw sequencing data. We will focus on the 3’ end sequencing used by droplet-based methods, such as inDrops, 10X Genomics, and Drop-seq.\n\nAfter sequencing, the sequencing facility will either output the raw sequencing data as BCL or FASTQ format or will generate the count matrix. If the reads are in BCL format, then we will need to convert to FASTQ format. There is a useful command-line tool called bcl2fastq that can easily perform this conversion.\n\n\n\n\n\n\nNote\n\n\n\nWe do not demultiplex at this step in the workflow. You may have sequenced 6 samples, but the reads for all samples may be present all in the same BCL or FASTQ file.\n\n\nThe generation of the count matrix from the raw sequencing data will go through similar steps for many of the scRNA-seq methods.\n\nalevin is a command-line tool that estimates expression of scRNA-seq data for which the 3’ ends of transcripts were sequenced. umi-tools and zUMIs are additional tools that can perform these processes. These tools incorporate collapsing of UMIs to correct for amplification bias. The steps in this process include the following:\n\nFormatting reads and filtering noisy cellular barcodes\nDemultiplexing the samples\nMapping/pseudo-mapping to transcriptome\nCollapsing UMIs and quantification of reads\n\nIf using 10X Genomics library preparation method, then the Cell Ranger pipeline would be used for all of the above steps.\n\n1. Formatting reads and filtering noisy cellular barcodes\nThe FASTQ files can then be used to parse out the cell barcodes, UMIs, and sample barcodes. For droplet-based methods, many of the cellular barcodes will match a low number of reads (&lt; 1000 reads) due to:\n\nencapsulation of free floating RNA from dying cells\nsimple cells (RBCs, etc.) expressing few genes\ncells that failed for some reason\n\nThese excess barcodes need to be filtered out of the sequence data prior to read alignment. To do this filtering, the ‘cellular barcode’ and the ‘molecular barcode’ are extracted and saved for each cell. For example, if using umi-tools, the information is added to the header line for each read, with the following format:\n@HWI-ST808:130:H0B8YADXX:1:1101:2088:2222:CELL_GGTCCA:UMI_CCCT\nAGGAAGATGGAGGAGAGAAGGCGGTGAAAGAGACCTGTAAAAAGCCACCGN\n+\n@@@DDBD&gt;=AFCF+&lt;CAFHDECII:DGGGHGIGGIIIEHGIIIGIIDHII#\nKnown cellular barcodes used in the library preparation method should be known, and unknown barcodes would be dropped, while allowing for an acceptable number of mismatches to the known cellular barcodes.\n\n\n2. Demultiplexing sample reads\nThe next step of the process is to demultiplex the samples, if sequencing more than a single sample. This is the one step of this process not handled by the umi-tools, but is accomplished by zUMIs. We would need to parse the reads to determine the sample barcode associated with each cell.\n\n\n3. Mapping/pseudo-mapping to cDNAs\nTo determine which gene the read originated from, the reads are aligned using traditional (STAR) or light-weight methods (Kallisto/RapMap).\n\n\n4. Collapsing UMIs and quantification of reads\nThe duplicate UMIs are collapsed, and only the unique UMIs are quantified using a tool like Kallisto or featureCounts. The resulting output is a cell by gene matrix of counts:\n\nImage credit: extracted from Lafzi et al. Tutorial: guidelines for the experimental design of single-cell RNA sequencing studies, Nature Protocols 2018 (https://doi.org/10.1038/s41596-018-0073-y)\nEach value in the matrix represents the number of reads in a cell originating from the corresponding gene. Using the count matrix, we can explore and filter the data, keeping only the higher quality cells."
  },
  {
    "objectID": "lessons/QC_bad_data.html",
    "href": "lessons/QC_bad_data.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/QC_bad_data.html#cell-counts",
    "href": "lessons/QC_bad_data.html#cell-counts",
    "title": "",
    "section": "Cell counts",
    "text": "Cell counts\nThe cell counts are determined by the number of unique cellular barcodes detected. During the droplet-based protocols, the cellular barcodes are present in the hydrogels, which are encapsulated in the droplets with a single cell and lysis/reaction mixture. While each hydrogel should have a single cellular barcode associated with it, occasionally a hydrogel can have more than one cellular barcode. We often see all possible combinations of cellular barcodes at a low level, leading to a higher number of cellular barcodes than cells.\nYou expect the number of unique cellular barcodes to be often greater than the number of seuqenced cells due to some hydrogels having more than one cellular barcode. The yellow sample below seems to have at least double the number of cellular barcodes as the other samples."
  },
  {
    "objectID": "lessons/QC_bad_data.html#umi-counts-per-cell",
    "href": "lessons/QC_bad_data.html#umi-counts-per-cell",
    "title": "",
    "section": "UMI counts per cell",
    "text": "UMI counts per cell\nThe number of UMIs per cell tends to be very low for the Unsorted sample (yellow). The other samples have good numbers of UMIs per cell, indicating a problem only with the Unsorted sample. Using this cutoff, we will lose the majority of the Unsorted cells."
  },
  {
    "objectID": "lessons/QC_bad_data.html#genes-detected-per-cell",
    "href": "lessons/QC_bad_data.html#genes-detected-per-cell",
    "title": "",
    "section": "Genes detected per cell",
    "text": "Genes detected per cell\nSeeing gene detection in the range of 500-5000 is normal for inDrop/10X analyses. However, expectations can vary depending on the complexity of the cells expected in the experiment. Similar expectations for gene detection as for UMI detection.\nAll samples other than the Unsorted sample have a good number of genes detected (with medians between 1,000 - 3,000 genes), which correspond to the numbers of UMIs per cell for each sample. However, the Unsorted sample has a very low median number of genes per cell, indicating a sample failure."
  },
  {
    "objectID": "lessons/QC_bad_data.html#umis-vs.-genes-detected",
    "href": "lessons/QC_bad_data.html#umis-vs.-genes-detected",
    "title": "",
    "section": "UMIs vs. genes detected",
    "text": "UMIs vs. genes detected\nPoor quality cells are likely to have low genes and UMIs per cell. Therefore, a poor sample is likely to have cells in the lower left of the graph. Good cells should exhibit both higher number of genes per cell and higher numbers of UMIs. We also expect similar lines with similar slopes for all samples.\nThe Unsorted sample has many cells with few UMIs and low number of genes per cell. The other samples look fine."
  },
  {
    "objectID": "lessons/QC_bad_data.html#mitochondrial-counts-ratio",
    "href": "lessons/QC_bad_data.html#mitochondrial-counts-ratio",
    "title": "",
    "section": "Mitochondrial counts ratio",
    "text": "Mitochondrial counts ratio\nPoor quality samples for mitochondrial counts would have larger peaks above the 0.1 mitochondrial ratio mark, unless it is expected based on sample type.\nThere was just a very low number of genes detected for the Unsorted sample, so mitochondrial expression appears higher mainly due to this fact. The poor quality of the Unsorted sample does not appear to be due to dead or dying cells. The other samples have little mitochondrial expression, although hPSC sample has a bit more than the Sorted samples. Since the hPSC sample was expected to have cell types with higher levels of mitochondrial expression, it may have been advisable to not to use a threshold for this metric."
  },
  {
    "objectID": "lessons/QC_bad_data.html#novelty",
    "href": "lessons/QC_bad_data.html#novelty",
    "title": "",
    "section": "Novelty",
    "text": "Novelty\nWe can see the samples where we sequenced each cell less have a higher overall novelty, that is because we have not started saturated the sequencing for any given gene for these samples. Outlier cells in these samples might be cells that we have a less complex RNA species than other cells. Sometimes we can detect contamination with low complexity cell types like red blood cells via this metric.\nAll of the samples look fine for complexity, except for the Unsorted sample, so it is unlikely that there is contamination with low complexity cell types in these of the samples. The Unsorted sample has a larger shoulder than desired, but is not bad by this metric."
  },
  {
    "objectID": "lessons/QC_bad_data.html#filtered-results",
    "href": "lessons/QC_bad_data.html#filtered-results",
    "title": "",
    "section": "Filtered results",
    "text": "Filtered results\nOne main plot to look at to determine the success of the filtering criteria is the number of cell counts. The number of cells to expect depends on the library preparation method, but for inDrops we see ~80% or less of the total sequenced cells per sample and for 10X it is often ~50% or less.\nCell counts\n\nIn addition, it is a good idea to explore all of the quality plots for the filtered data. All plots should be much improved for the number of reads per cell, genes detected, UMIs per cell, mitochondrial ratio, and novelty. Since the Unsorted sample was a poor quality sample, the filter will remove a large number of the cells for this sample; in this case all cells except 1 were filtered out."
  },
  {
    "objectID": "lessons/sc_exercises_qc_analysis.html",
    "href": "lessons/sc_exercises_qc_analysis.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\nAnswer key - Quality Control Analysis\n1. Extract the new metadata from the filtered Seurat object using the code provided below:\n\n# Save filtered subset to new metadata\nmetadata_clean &lt;- filtered_seurat@meta.data\n\n2. Perform all of the same QC plots using the filtered data.\n\nCell counts\nAfter filtering, we should not have more cells than we sequenced. Generally we aim to have about the number we sequenced or a bit less.\n\n## Cell counts\nmetadata_clean %&gt;% \n    ggplot(aes(x=sample, fill=sample)) + \n    geom_bar() +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +\n    theme(plot.title = element_text(hjust=0.5, face=\"bold\")) +\n    ggtitle(\"NCells\")\n\n\n\n\n\n\nUMI counts\nThe filtering using a threshold of 500 has removed the cells with low numbers of UMIs from the analysis.\n\n# UMI counts\nmetadata_clean %&gt;% \n    ggplot(aes(color=sample, x=nUMI, fill= sample)) + \n    geom_density(alpha = 0.2) + \n    scale_x_log10() + \n    theme_classic() +\n    ylab(\"log10 cell density\") +\n    geom_vline(xintercept = 500)\n\n\n\n\n\n\nGenes detected\n\n# Genes detected\nmetadata_clean %&gt;% \n    ggplot(aes(color=sample, x=nGene, fill= sample)) + \n    geom_density(alpha = 0.2) + \n    theme_classic() +\n    scale_x_log10() + \n    geom_vline(xintercept = 250)\n\n\n\n\n\n\nUMIs vs genes\n\n# UMIs vs genes\nmetadata_clean %&gt;% \n  ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500) +\n  geom_hline(yintercept = 250) +\n  facet_wrap(~sample)\n\n\n\n\n\n\nMitochondrial counts ratio\n\n# Mitochondrial counts ratio\nmetadata_clean %&gt;% \n    ggplot(aes(color=sample, x=mitoRatio, fill=sample)) + \n    geom_density(alpha = 0.2) + \n    scale_x_log10() + \n    theme_classic() +\n    geom_vline(xintercept = 0.2)\n\n\n\n\n\n\nNovelty\n\n# Novelty\nmetadata_clean %&gt;%\n    ggplot(aes(x=log10GenesPerUMI, color = sample, fill=sample)) +\n    geom_density(alpha = 0.2) +\n    theme_classic() +\n    geom_vline(xintercept = 0.8)\n\n\n\n\n3. Report the number of cells left for each sample, and comment on whether the number of cells removed is high or low. Can you give reasons why this number is still not ~12K (which is how many cells were loaded for the experiment)?\nThere are just under 15K cells left for both the control and stim cells. The number of cells removed is reasonably low.\nWhile it would be ideal to have 12K cells, we do not expect that due to the lower capture efficiency (i.e. the number of actual cells encapsulated within droplets containing barcodes) of these technologies. If we still see higher than expected numbers of cells after filtering, this means we could afford to filter more stringently (but we don’t necessarily have to).\n4. After filtering for nGene per cell, you should still observe a small shoulder to the right of the main peak. What might this shoulder represent?\nThis peak could represent a biologically distinct population of cells. It could be a set a of cells that share some properties and as a consequence exhibit more diversity in its transcriptome (with the larger number of genes detected).\n5. When plotting the nGene against nUMI do you observe any data points in the bottom right quadrant of the plot? What can you say about these cells that have been removed?\nThe cells that were removed were those with high nUMI but low numbers of genes detected. These cells had many captured transcripts but represent only a small number of genes. These low complexity cells could represent a specific cell type (i.e. red blood cells which lack a typical transcriptome), or could be due to some other strange artifact or contamination."
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html",
    "href": "lessons/01_intro_to_scRNA-seq.html",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "Across human tissues there is an incredible diversity of cell types, states, and interactions. To better understand these tissues and the cell types present, single-cell RNA-seq (scRNA-seq) offers a glimpse into what genes are being expressed at the level of individual cells.\n\nImage credit: courtesy of Dr. Ayshwarya Subramanian\nThis exciting and cutting-edge method can be used to:\n\nExplore which cell types are present in a tissue\nIdentify unknown/rare cell types or states\nElucidate the changes in gene expression during differentiation processes or across time or states\nIdentify genes that are differentially expressed in particular cell types between conditions (e.g. treatment or disease)\nExplore changes in expression among a cell type while incorporating spatial, regulatory, and/or protein information\n\nPopular methods to address some of the more common investigations include:\n\n\n\n\nPrior to scRNA-seq, transcriptome analysis was performed using bulk RNA-seq, which is a method for comparing the averages of cellular expression. This method can be a good choice if looking at comparative transcriptomics (e.g. samples of the same tissue from different species), and for quantifying expression signatures in disease studies. It also has potential for the discovery of disease biomarkers if you are not expecting or not concerned about cellular heterogeneity in the sample.\nWhile bulk RNA-seq can explore differences in gene expression between conditions (e.g. treatment or disease), the differences at the cellular level are not adequately captured. For instance, in the images below, if analyzed in bulk (left) we would not detect the correct association between the expression of gene A and gene B. However, if we properly group the cells by cell type or cell state, we can see the correct correlation between the genes.\n\nImage credit: Trapnell, C. Defining cell types and states with single-cell genomics, Genome Research 2015 (doi: https://dx.doi.org/10.1101/gr.190595.115)\nDespite scRNA-seq being able to capture expression at the cellular level, sample generation and library preparation is more expensive and the analysis is much more complicated and more difficult to interpret. The complexity of analysis of scRNA-seq data involves:\n\nLarge volume of data\nLow depth of sequencing per cell\nTechnical variability across cells/samples\nBiological variability across cells/samples\n\nWe will explore each of these complexities in more detail below:\n\n\nExpression data from scRNA-seq experiments represent tens or hundreds of thousands of reads for thousands of cells. The data output is much larger, requiring higher amounts of memory to analyze, larger storage requirements, and more time to run the analyses.\n\n\n\nFor the droplet-based methods of scRNA-seq, the depth of sequencing is shallow, often detecting only 10-50% of the transcriptome per cell. This results in cells showing zero counts for many of the genes. However, in a particular cell, a zero count for a gene could either mean that the gene was not being expressed or the transcripts were just not detected. Across cells, genes with higher levels of expression tend to have fewer zeros. Due to this feature, many genes will not be detected in any cell and gene expression will be highly variable between cells.\n\n\n\n\n\n\nZero-inflated?\n\n\n\nscRNA-seq data is often referred to as zero-inflated; however, recent analyses suggest that it does not contain more zeros than what would be expected given the sequencing depth [Valentine Svensson’s blog post]. A more recent paper discussing modeling of scRNA-seq data is also available.\n\n\n\n\n\nUninteresting sources of biological variation can result in gene expression between cells being more similar/different than the actual biological cell types/states, which can obscure the cell type identities. Uninteresting sources of biological variation (unless part of the experiment’s study) include:\n\nTranscriptional bursting: Gene transcription is not turned on all of the time for all genes. Time of harvest will determine whether gene is on or off in each cell.\nVarying rates of RNA processing: Different RNAs are processed at different rates.\nContinuous or discrete cell identities (e.g. the pro-inflammatory potential of each individual T cell): Continuous phenotypes are by definition variable in gene expression, and separating the continuous from the discrete can sometimes be difficult.\nEnvironmental stimuli: The local environment of the cell can influence the gene expression depending on spatial position, signaling molecules, etc.\nTemporal changes: Fundamental fluxuating cellular processes, such as cell cycle, can affect the gene expression profiles of individual cells.\n\n\nImage credit: Wagner, A, et al. Revealing the vectors of cellular identity with single-cell genomics, Nat Biotechnol. 2016 (doi:https://dx.doi.org/10.1038%2Fnbt.3711)\n\n\n\nTechnical sources of variation can result in gene expression between cells being more similar/different based on technical sources instead of biological cell types/states, which can obscure the cell type identities. Technical sources of variation include:\n\nCell-specific capture efficiency: Different cells will have differing numbers of transcripts captured resulting in differences in sequencing depth (e.g. 10-50% of transcriptome).\nLibrary quality: Degraded RNA, low viability/dying cells, lots of free floating RNA, poorly dissociated cells, and inaccurate quantitation of cells can result in low quality metrics\nAmplification bias: During the amplification step of library preparation, not all transcripts are amplified to the same level.\nBatch effects: Batch effects are a significant issue for scRNA-Seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nTo explore the issues generated by poor batch study design, they are highlighted nicely in this paper.\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO split replicates of the different sample groups across batches. The more replicates the better (definitely more than 2), if doing DE across conditions or making conclusions at the population level. If using inDrops, which prepares a single library at a time, alternate the sample groups (e.g. don’t prepare all control libraries first, then prepare all treatment libraries).\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO include batch information in your experimental metadata. During the analysis, we can regress out variation due to batch or integrate across batches, so it doesn’t affect our results if we have that information.\n\n\n\n\n\n\n\nWhile scRNA-seq is a powerful and insightful method for the analysis of gene expression with single-cell resolution, there are many challenges and sources of variation that can make the analysis of the data complex or limited. Throughout the analysis of scRNA-seq data, we will try to account for or regress out variation due to the various sources of uninteresting variation in our data.\nOverall, we recommend the following:\n\nDo not perform single-cell RNA-seq unless it is necessary for the experimental question of interest. Could you answer the question using bulk sequencing, which is simpler and less costly? Perhaps FACS sorting the samples could allow for bulk analysis?\nUnderstand the details of the experimental question you wish to address. The recommended library preparation method and analysis workflow can vary based on the specific experiment.\nAvoid technical sources of variability, if possible:\n\nDiscuss experimental design with experts prior to the initiation of the experiment\nIsolate RNA from samples at same time\nPrepare libraries at same time or alternate sample groups to avoid batch confounding\nDo not confound sample groups by sex, age, or batch\n\n\n\n\n\n\n\n\n\nHow does single-nucleus RNA-seq (snRNA-seq) compare to single-cell RNA-seq?\n\n\n\nWe will not be covering snRNA-seq in this workshop! Below is a brief overview of snRNA-seq.\nsnRNA-seq analyzes the expression profiles from nuclei, instead of intact cells. As you may expect, fewer transcripts are detected from the nuclei (~7,000 genes), compared to intact cells (~11,000 genes). In some situations (depending on your research materials and goals), snRNA-seq can be the preferred method as opposed to scRNA-seq.\nSome advantages of snRNA-seq include: * Works well with hard-to-isolate samples (for example, adipocytes), as well as frozen tissues * Reduces transcriptional artifacts from the isolation process * Provides less biased cellular coverage"
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html#why-single-cell-rna-seq",
    "href": "lessons/01_intro_to_scRNA-seq.html#why-single-cell-rna-seq",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "Across human tissues there is an incredible diversity of cell types, states, and interactions. To better understand these tissues and the cell types present, single-cell RNA-seq (scRNA-seq) offers a glimpse into what genes are being expressed at the level of individual cells.\n\nImage credit: courtesy of Dr. Ayshwarya Subramanian\nThis exciting and cutting-edge method can be used to:\n\nExplore which cell types are present in a tissue\nIdentify unknown/rare cell types or states\nElucidate the changes in gene expression during differentiation processes or across time or states\nIdentify genes that are differentially expressed in particular cell types between conditions (e.g. treatment or disease)\nExplore changes in expression among a cell type while incorporating spatial, regulatory, and/or protein information\n\nPopular methods to address some of the more common investigations include:"
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html#challenges-of-scrna-seq-analysis",
    "href": "lessons/01_intro_to_scRNA-seq.html#challenges-of-scrna-seq-analysis",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "Prior to scRNA-seq, transcriptome analysis was performed using bulk RNA-seq, which is a method for comparing the averages of cellular expression. This method can be a good choice if looking at comparative transcriptomics (e.g. samples of the same tissue from different species), and for quantifying expression signatures in disease studies. It also has potential for the discovery of disease biomarkers if you are not expecting or not concerned about cellular heterogeneity in the sample.\nWhile bulk RNA-seq can explore differences in gene expression between conditions (e.g. treatment or disease), the differences at the cellular level are not adequately captured. For instance, in the images below, if analyzed in bulk (left) we would not detect the correct association between the expression of gene A and gene B. However, if we properly group the cells by cell type or cell state, we can see the correct correlation between the genes.\n\nImage credit: Trapnell, C. Defining cell types and states with single-cell genomics, Genome Research 2015 (doi: https://dx.doi.org/10.1101/gr.190595.115)\nDespite scRNA-seq being able to capture expression at the cellular level, sample generation and library preparation is more expensive and the analysis is much more complicated and more difficult to interpret. The complexity of analysis of scRNA-seq data involves:\n\nLarge volume of data\nLow depth of sequencing per cell\nTechnical variability across cells/samples\nBiological variability across cells/samples\n\nWe will explore each of these complexities in more detail below:\n\n\nExpression data from scRNA-seq experiments represent tens or hundreds of thousands of reads for thousands of cells. The data output is much larger, requiring higher amounts of memory to analyze, larger storage requirements, and more time to run the analyses.\n\n\n\nFor the droplet-based methods of scRNA-seq, the depth of sequencing is shallow, often detecting only 10-50% of the transcriptome per cell. This results in cells showing zero counts for many of the genes. However, in a particular cell, a zero count for a gene could either mean that the gene was not being expressed or the transcripts were just not detected. Across cells, genes with higher levels of expression tend to have fewer zeros. Due to this feature, many genes will not be detected in any cell and gene expression will be highly variable between cells.\n\n\n\n\n\n\nZero-inflated?\n\n\n\nscRNA-seq data is often referred to as zero-inflated; however, recent analyses suggest that it does not contain more zeros than what would be expected given the sequencing depth [Valentine Svensson’s blog post]. A more recent paper discussing modeling of scRNA-seq data is also available.\n\n\n\n\n\nUninteresting sources of biological variation can result in gene expression between cells being more similar/different than the actual biological cell types/states, which can obscure the cell type identities. Uninteresting sources of biological variation (unless part of the experiment’s study) include:\n\nTranscriptional bursting: Gene transcription is not turned on all of the time for all genes. Time of harvest will determine whether gene is on or off in each cell.\nVarying rates of RNA processing: Different RNAs are processed at different rates.\nContinuous or discrete cell identities (e.g. the pro-inflammatory potential of each individual T cell): Continuous phenotypes are by definition variable in gene expression, and separating the continuous from the discrete can sometimes be difficult.\nEnvironmental stimuli: The local environment of the cell can influence the gene expression depending on spatial position, signaling molecules, etc.\nTemporal changes: Fundamental fluxuating cellular processes, such as cell cycle, can affect the gene expression profiles of individual cells.\n\n\nImage credit: Wagner, A, et al. Revealing the vectors of cellular identity with single-cell genomics, Nat Biotechnol. 2016 (doi:https://dx.doi.org/10.1038%2Fnbt.3711)\n\n\n\nTechnical sources of variation can result in gene expression between cells being more similar/different based on technical sources instead of biological cell types/states, which can obscure the cell type identities. Technical sources of variation include:\n\nCell-specific capture efficiency: Different cells will have differing numbers of transcripts captured resulting in differences in sequencing depth (e.g. 10-50% of transcriptome).\nLibrary quality: Degraded RNA, low viability/dying cells, lots of free floating RNA, poorly dissociated cells, and inaccurate quantitation of cells can result in low quality metrics\nAmplification bias: During the amplification step of library preparation, not all transcripts are amplified to the same level.\nBatch effects: Batch effects are a significant issue for scRNA-Seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nTo explore the issues generated by poor batch study design, they are highlighted nicely in this paper.\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO split replicates of the different sample groups across batches. The more replicates the better (definitely more than 2), if doing DE across conditions or making conclusions at the population level. If using inDrops, which prepares a single library at a time, alternate the sample groups (e.g. don’t prepare all control libraries first, then prepare all treatment libraries).\n\nImage credit: Hicks SC, et al., bioRxiv (2015)\nDO include batch information in your experimental metadata. During the analysis, we can regress out variation due to batch or integrate across batches, so it doesn’t affect our results if we have that information."
  },
  {
    "objectID": "lessons/01_intro_to_scRNA-seq.html#conclusions",
    "href": "lessons/01_intro_to_scRNA-seq.html#conclusions",
    "title": "Introduction to single-cell RNA-seq",
    "section": "",
    "text": "While scRNA-seq is a powerful and insightful method for the analysis of gene expression with single-cell resolution, there are many challenges and sources of variation that can make the analysis of the data complex or limited. Throughout the analysis of scRNA-seq data, we will try to account for or regress out variation due to the various sources of uninteresting variation in our data.\nOverall, we recommend the following:\n\nDo not perform single-cell RNA-seq unless it is necessary for the experimental question of interest. Could you answer the question using bulk sequencing, which is simpler and less costly? Perhaps FACS sorting the samples could allow for bulk analysis?\nUnderstand the details of the experimental question you wish to address. The recommended library preparation method and analysis workflow can vary based on the specific experiment.\nAvoid technical sources of variability, if possible:\n\nDiscuss experimental design with experts prior to the initiation of the experiment\nIsolate RNA from samples at same time\nPrepare libraries at same time or alternate sample groups to avoid batch confounding\nDo not confound sample groups by sex, age, or batch\n\n\n\n\n\n\n\n\n\nHow does single-nucleus RNA-seq (snRNA-seq) compare to single-cell RNA-seq?\n\n\n\nWe will not be covering snRNA-seq in this workshop! Below is a brief overview of snRNA-seq.\nsnRNA-seq analyzes the expression profiles from nuclei, instead of intact cells. As you may expect, fewer transcripts are detected from the nuclei (~7,000 genes), compared to intact cells (~11,000 genes). In some situations (depending on your research materials and goals), snRNA-seq can be the preferred method as opposed to scRNA-seq.\nSome advantages of snRNA-seq include: * Works well with hard-to-isolate samples (for example, adipocytes), as well as frozen tissues * Reduces transcriptional artifacts from the isolation process * Provides less biased cellular coverage"
  },
  {
    "objectID": "lessons/readMM_loadData.html",
    "href": "lessons/readMM_loadData.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\nCreating count data object\nGenerally, all single-cell RNA-seq datasets, regardless of technology or pipeline, will contain three files:\n\na file with the gene IDs, representing all genes quantified\na file with the cell IDs, representing all cells quantified\na matrix of counts per gene for every cell\n\nWe can explore these files by clicking on the data/ctrl_raw_feature_bc_matrix folder:\n\nbarcodes.tsv: cellular barcodes present in dataset\n\n\n\nfeatures.tsv: IDs of quantified genes\n\n\n\nmatrix.mtx: a matrix of count values, where rows are associated with the gene IDs above and columns correspond to the cellular barcodes. Note that there are many zero values in this matrix.\n\n\nWe can create a count matrix using these files. However, instead of creating a standard count matrix, we will create a sparse matrix to improve the amount of space, memory and CPU required to work with our huge count matrix.\n\nlibrary(Matrix)\nlibrary(readr)\n\nWe will use readMM() function from the Matrix package to turn our standard matrix into a sparse matrix. The genes.tsv file should correspond to the genes or row names of the matrix, while barcodes.tsv corresponds to the cells or columns.\n\n# Read in `matrix.mtx`\ncounts &lt;- readMM(\"../data/ctrl_raw_feature_bc_matrix/matrix.mtx.gz\")\n\n# Read in `genes.tsv`\ngenes &lt;- read_tsv(\"../data/ctrl_raw_feature_bc_matrix/features.tsv.gz\",\n                  col_names = FALSE)\ngene_ids &lt;- genes$X1\n\n# Read in `barcodes.tsv`\ncell_ids &lt;- read_tsv(\"../data/ctrl_raw_feature_bc_matrix/barcodes.tsv.gz\",\n                     col_names = FALSE)\ncell_ids &lt;- cell_ids$X1\n\nThen we can add row names to the count matrix to be the gene IDs and the column names of the count matrix to be the cell IDs.\n\n# Make the column names as the cell IDs and the row names as the gene IDs\nrownames(counts) &lt;- gene_ids\ncolnames(counts) &lt;- cell_ids\n\nWe could use this data for downstream QC analysis. However, this would take a long time if we had multiple samples. A quicker way to load multiple samples is to use the Seurat R package, which has a specific function for reading in 10X data, called read10X().\n\n\n\n\n\n\nNote\n\n\n\nIf using other droplet-based methods for library preparation, the above method would be needed to perform the QC. We have additional materials available based on creation of the count matrix in this way."
  },
  {
    "objectID": "lessons/04_cellranger_QC.html",
    "href": "lessons/04_cellranger_QC.html",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "",
    "text": "Approximate time: 30 minutes"
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#learning-objectives",
    "href": "lessons/04_cellranger_QC.html#learning-objectives",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe how cellranger is run and what the ouputs are\nReview the cellranger generated QC report (web summary HTML)\nCreate plots with cellranger metrics"
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#cellranger",
    "href": "lessons/04_cellranger_QC.html#cellranger",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Cellranger",
    "text": "Cellranger\nCellranger is a tool created by the company 10x to process single-cell sequencing experiments that were processed with their kits.\nThe algorithm for the single-cell RNA-seq (scRNA) version of cellranger is described by 10x as follows:\n\nImage credit: 10x\nThe main elements of this pipeline are as follows:\n\nAlign FASTQ reads against a reference genome\nFilter low quailty reads and correct cell barcodes/UMIs\nCollapse on PCR duplicates using UMIs\nGenerate raw counts matrix\nIdentify low quality cells to generate a filtered counts matrix\n\nWhile the focus of this workshop is scRNA, we also want to point out that there are other cellranger softwares and modes for different types of single-cell experiments.\n\n\n\nExperiment\nExperiment description\n10x tool\n\n\n\n\nRNA\nRNA\ncellranger count\n\n\nATAC\nATAC\ncellranger-atac count\n\n\nMultiome\nRNA + ATAC\ncellranger-arc count\n\n\nV(D)J\nClonotyping of T and B cells\ncellranger vdj\n\n\nHashtagging\nAntibody/oligo tags to differentiate cells after pooling\ncellranger multi"
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#running-cellranger-on-o2",
    "href": "lessons/04_cellranger_QC.html#running-cellranger-on-o2",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Running Cellranger on O2",
    "text": "Running Cellranger on O2\nRunning cellranger requires a lot of time and computational resources in order to process a single sample. Therefore, having access to a High Performance Computing (HPC) cluster is necessary to run it. Some sequencing cores will automatically process samples with cellranger and provide the outputs to you.\nNote that prior to this step, you must have a cellranger compatible reference genome generated. If you are working with mouse or human, 10x has pre-generated the reference which can be downloaded from their website for use. If you are using another organism, cellranger has a mode called mkref which will generate everything needed for a reference from the files you supply (GTF and fasta).\nHere we are showing an example of how to run cellranger count on Harvard’s O2 HPC using SLURM. To run this script, you will have add additional information, such as:\n\nThe name of the project (the results will be placed in a folder of the same name)\nPath to the FASTQ files from your experiment\nPath to the reference genome\n\nIn the following example script, you would just have to change the variable specified in the “Inputs for cellranger” section on eth 10x support site. We have already provided some optimal parameters in terms of runtime and memory for running cellranger count.\nYou do not need to run this script.\n\n#!/bin/bash\n\n#SBATCH --partition=short               # Partition name\n#SBATCH --time=0-06:00                  # Runtime in D-HH:MM format\n#SBATCH --nodes=1                       # Number of nodes (keep at 1)\n#SBATCH --ntasks=1                      # Number of tasks per node (keep at 1)\n#SBATCH --cpus-per-task=16              # CPU cores requested per task (change for threaded jobs)\n#SBATCH --mem=64G                       # Memory needed per node (total)\n#SBATCH --error=jobid_%j.err            # File to which STDERR will be written, including job ID\n#SBATCH --output=jobid_%j.out           # File to which STDOUT will be written, including job ID\n#SBATCH --mail-type=ALL                 # Type of email notification (BEGIN, END, FAIL, ALL)\n\nmodule load gcc\nmodule load cellranger/7.1.0\n\nlocal_cores=16\nlocal_mem=64\n\n# Inputs for cellranger\nproject_name=\"\"                         # Name of output\npath_fastq=\"/path/to/fastq/\"             # Path to folder with FASTQ files for one sample\npath_ref=\"/path/to/reference/\"           # Path to cellranger compatible reference\n\n\ncellranger count \\\n    --id=${project_name} \\\n    --fastqs=${path_fastq} \\\n    --transcriptome=${path_ref} \\\n    --localcores=${local_cores} \\\n    --localmem=${local_mem}"
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#cellranger-outs",
    "href": "lessons/04_cellranger_QC.html#cellranger-outs",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Cellranger outs",
    "text": "Cellranger outs\nOnce cellranger has finished running, there will be a folder titled outs/ in a directory named after the project_name variable set above. Generation of all the following files is expected from a succesful completion of the cellranger counts pipeline:\n\n├── cloupe.cloupe\n├── filtered_feature_bc_matrix\n│   ├── barcodes.tsv.gz\n│   ├── features.tsv.gz\n│   └── matrix.mtx.gz\n├── filtered_feature_bc_matrix.h5\n├── metrics_summary.csv\n├── molecule_info.h5\n├── possorted_genome_bam.bam\n├── possorted_genome_bam.bam.bai\n├── raw_feature_bc_matrix\n│   ├── barcodes.tsv.gz\n│   ├── features.tsv.gz\n│   └── matrix.mtx.gz\n├── raw_feature_bc_matrix.h5\n└── web_summary.html"
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#web-summary-html-report",
    "href": "lessons/04_cellranger_QC.html#web-summary-html-report",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Web summary HTML Report",
    "text": "Web summary HTML Report\nThe Web Summary HTML file is a great resource for looking at the basic quality of your sample before starting on an analysis. 10x has a page describing each metric in depth. There are two pages/tabs included in a scRNA report titled “Summary” and “Gene Expression”.\nWe have included these Web Summary files for the control and stimulated samples as links below. You can download each, and move the HTML to your project data folder:\n\nControl sample report\nStimulated sample report\n\n\n\n\n\n\n\nNote\n\n\n\nSome of the values in these reports will be slightly different from current standards, as these samples were generated using the version 1 chemistry kit and optimization have been made since then.\n\n\n\nSummary\nAt the top of the “Summary” tab, under the “Alerts” header, will be a list of warnings and messages on the quality/important information about the sample. These messages are very informative on what may have gone wrong with the sample or other flags that can be set in the cellranger count run to gain better results.\nUnderneath the “Alerts” header, in green text, are the estimated number of high quality cells in the sample, average reads per cells, and median genes per cell. The number of cells will vary depending on how many were loaded in sample preparation, but some general recommendations are provided below:\n\n500 cells is the lower limit for a good quality sample.\n10x also recommends a minimum of 20,000 reads per cell on average.\nThe median genes per cell varies widely across samples as it depends on sequencing depth and cell type, making it difficult to establish a good minimal value.\n\nThe remaining 4 sections include various metrics that describe the overall quality of the sample. Note that clicking on the grey question mark will show more detailed explanations.\nSequencing\nIncludes information such as the total number of reads and how many of those reads did not meet the length requirements. Additionally, since all barcodes and UMIs are known values (from the kit used to prep scRNA experiments), we can evaluate what percentage of the barcodes and UMIs belong to that whitelist and are valid.\n\nIdeally, you would like to see &gt;75% for almost all of these values since lower values are indicative of a low quality sequencing run or bad sample quality.\nMapping\nPercentage of reads that map to different regions of the reference genome as reported by STAR.\n\nThe percent of reads mapped to the genome should be on the higher end, around 85% or higher. Values that are very low could indicate that the reference genome supplied was incorrect or that the sample was problematic. Otherwise, the expectation for a scRNA runs is that the majority of reads will belong to exonic regions. If nuclei were used instead of whole cells, the percentage of reads mapping to intronic regions will be higher (~45%).\nCells\nHere we can see what an ideal representation of the Barcode Rank Plot looks like. The cells are sorted by the number of UMIs found in the cell to differentiate empty droplets/low quality cells (background) from actual cells.\n\nImage credit: 10x\nThe shape of these plots can indicate a few different things about the sample:\n\nTypical: Clear cliff and knee with separation between cells and background.\nHeterogeneous: Bimodal plot with 2 cliffs and knees, with a clear divide between cells and background.\nCompromised: Round curve with a steep drop-off at the end whih indicated low quality due to many factors.\nCompromised: Defined cliff and knee, but with few barcodes detected could be due to inaccurate cell count or clogging.\n\nThis section additionally describes averages and medians for number of genes and reads in the sample.\nSample\nThe sample section contains important metadata used by cellranger, such as what the Sample ID and the path used for the reference. The chemistry version (which 10x kit was used) and intron flags are also stored here. This information is useful for reproducibility reasons, as the version of cellranger used is also kept.\n\n\n\nGene Expression\nThe “Gene Expression” table contains information downstream of the basic QC, such as:\nt-SNE Projection\nDotplot showing the t-SNE projection of filtered cells colored by UMI counts and clusters. The report allows you select various values of K for the K-means clustering, showing different groupings that can be generated from the data.\n\nLater in the workshop we will spend more time on the intricacies of clustering. The requirements for this QC report would be to see clear separation of cells into groups with defined clusters - representing different cell types.\nTop Features by Cluster\nThis table shows the log2 fold-change and p-value for each gene and cluster after a differential expression analysis is run.\n\nThese top genes per cluster can give a brief peek into the cell type distribution of the sample. If no expected cell type marker genes appear or mitochondrial/ribosomal genes show up frequently, this can be indicative of something wrong with the sample.\nSequencing Saturation and Median Genes per Cell\nThe sequencing saturation plot is a measure of library complexity. In scRNA, more genes can be detected with higher sequencing depth. At a point, you reach sequencing saturation where you do not gain any more meaningful insights which is what the dotted line represents here.\nSimilar to the sequencing saturation plot, looking at the median gene per cells against mean reads per cell will indicate if your have over or under-sequenced. The slope near the endpoint can be used to determine how much benefit would be gained from sequencing more deeply."
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#metrics-evaluation",
    "href": "lessons/04_cellranger_QC.html#metrics-evaluation",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Metrics evaluation",
    "text": "Metrics evaluation\nMany of the core pieces of information from the web summary are stored in the metrics_summary.csv. As this is a csv file, we can read it into R and generate plots to include in reports on the general quality of the samples.\nWe have included these csv files for the control and stimulated samples as links below. You can right-click on the link and “Save as…” into your project data folder:\n\nControl sample metrics.csv file\nStimulated sample metrics.csv file\n\nFirst, to read the files in:\n\nlibrary(tidyverse)\nlibrary(reshape2)\nlibrary(plyr)\n\n# Names of samples (same name as folders stored in data)\nsamples &lt;- c(\"ctrl\", \"stim\")\n\n# Loop over each sample and read the metrics summary in\nmetrics &lt;- list()\nfor (sample in samples) {\n    path_csv &lt;- paste0(\"../data/\", sample, \"_metrics_summary.csv\")\n    df &lt;- read.csv(path_csv)\n    rownames(df) &lt;- sample\n    metrics[[sample]] &lt;- df\n}\n# Concatenate each sample metrics together\nmetrics &lt;- ldply(metrics, rbind)\n# Remove periods and percentags to make the values numeric\nmetrics &lt;- metrics %&gt;%\n    column_to_rownames(\".id\") %&gt;%\n    mutate_all(funs(parse_number(str_replace(., \",\", \"\")))) %&gt;%\n    mutate_all(funs(parse_number(str_replace(., \"%\", \"\"))))\nmetrics$sample &lt;- rownames(metrics)\n\nThe information available in this file include:\n\ncolnames(metrics)\n\n [1] \"Estimated.Number.of.Cells\"                     \n [2] \"Mean.Reads.per.Cell\"                           \n [3] \"Median.Genes.per.Cell\"                         \n [4] \"Number.of.Reads\"                               \n [5] \"Valid.Barcodes\"                                \n [6] \"Sequencing.Saturation\"                         \n [7] \"Q30.Bases.in.Barcode\"                          \n [8] \"Q30.Bases.in.RNA.Read\"                         \n [9] \"Q30.Bases.in.UMI\"                              \n[10] \"Reads.Mapped.to.Genome\"                        \n[11] \"Reads.Mapped.Confidently.to.Genome\"            \n[12] \"Reads.Mapped.Confidently.to.Intergenic.Regions\"\n[13] \"Reads.Mapped.Confidently.to.Intronic.Regions\"  \n[14] \"Reads.Mapped.Confidently.to.Exonic.Regions\"    \n[15] \"Reads.Mapped.Confidently.to.Transcriptome\"     \n[16] \"Reads.Mapped.Antisense.to.Gene\"                \n[17] \"Fraction.Reads.in.Cells\"                       \n[18] \"Total.Genes.Detected\"                          \n[19] \"Median.UMI.Counts.per.Cell\"                    \n[20] \"sample\"                                        \n\n\nWith all of this information available as a dataframe, we can use ggplot to visualize these values. As an example of how this information can be used, we can display what percentage of reads map to the various parts of the genome (Intergentic, Intronic, and Exonic).\n\n# Columns of interest\ncols &lt;- c(\"Reads.Mapped.Confidently.to.Intergenic.Regions\",\n          \"Reads.Mapped.Confidently.to.Intronic.Regions\",\n          \"Reads.Mapped.Confidently.to.Exonic.Regions\",\n          \"sample\")\n\n# Data wrangling to sculpt dataframe in a ggplot friendly manner\ndf &lt;- metrics %&gt;%\n    select(cols) %&gt;%\n    melt() %&gt;%\n    mutate(variable = str_replace_all(variable, \"Reads.Mapped.Confidently.to.\", \"\")) %&gt;%\n    mutate(variable = str_replace_all(variable, \".Regions\", \"\"))\n\n# ggplot code to make a barplot\ndf %&gt;% ggplot() +\n    geom_bar(\n        aes(x = sample, y = value, fill = variable),\n        position = \"stack\",\n        stat = \"identity\") +\n    coord_flip() +\n    labs(\n        x = \"Sample\",\n        y = \"Percentage of Reads\",\n        title = \"Percent of Reads Mapped to Each Region\",\n        fill = \"Region\")"
  },
  {
    "objectID": "lessons/04_cellranger_QC.html#matrix-folders",
    "href": "lessons/04_cellranger_QC.html#matrix-folders",
    "title": "Single-cell RNA-seq: Quality Control of Cellranger Output",
    "section": "Matrix folders",
    "text": "Matrix folders\nThe most important files that are generated during this cellranger run are the two matrix folders, which contain the count matrices from the experiment:\n\nraw_feature_bc_matrix\nfiltered_feature_bc_matrix\n\nIn the previous lesson, we used raw_feature_bc_matrix to load the counts into Seurat. You can similarly do the same with filtered_feature_bc_matrix, the difference being that the filtered matrix has removed cells that cellranger determined as low quality using a variety of different tools. We chose to start with the raw counts matrix in this lesson so that you can better see what metrics are used to determine which cells are considered high quality."
  },
  {
    "objectID": "lessons/schedule.html",
    "href": "lessons/schedule.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/schedule.html#pre-reading",
    "href": "lessons/schedule.html#pre-reading",
    "title": "",
    "section": "Pre-reading",
    "text": "Pre-reading\n\nIntroduction to scRNA-seq\nRaw data to count matrix\nDownload this project"
  },
  {
    "objectID": "lessons/schedule.html#day-1",
    "href": "lessons/schedule.html#day-1",
    "title": "",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 09:45\nWorkshop introduction\nWill\n\n\n09:45 - 10:35\nIntroduction to Single Cell RNA-sequencing: a practical guide\nDr. Arpita Kulkarni\n\n\n10:35 - 10:40\nBreak\n\n\n\n10:40 - 11:00\nscRNA-seq pre-reading discussion\nAll\n\n\n11:00 - 11:45\nQuality control set-up\nNoor\n\n\n11:45 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\nBefore the next class:\nI. Please study the contents and work through all the code within the following lessons:\n\nQuality control of cellranger counts\n\n\nClick here for a preview of this lesson\n\nBefore you start any analysis, it’s important to know whether or not you have good quality cells. At these early stages you can flag or remove samples that could produce erroneous results downstream. In this lesson you will: - Discuss the outputs of cellranger and how to run it  - Review web summary HTML report - Create plots from metrics_summary.csv file \n\nQuality control with additional metrics\n\n\nClick here for a preview of this lesson\n\nIn addition to the QC generated by cellranger, we can also compute some of our own metrics based on the raw data we have loaded into our Seurat object. In this lesson you will: - Compute essential QC metrics for each sample - Create plots to visualize metrics across cells per sample - Critically evaluate each plot and learn what each QC metric means\n\nTheory of PCA\n\n\nClick here for a preview of this lesson\n\nBefore we can begin the next steps of the workflow, we need to make sure you have a good understanding of Principal Components Analysis (PCA). This method will be utilized in the scRNA-seq analysis workflow, and this foundation will help you better navigate those steps and interpretation of results.\n\n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\nQuestions?\n\nIf you get stuck due to an error while runnning code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-2",
    "href": "lessons/schedule.html#day-2",
    "title": "",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 10:15\nSelf-learning lessons discussion\nAll\n\n\n10:15 - 11:15\nNormalization and regressing out unwanted variation\nNoor\n\n\n11:15 - 11:25\nBreak\n\n\n\n11:25 - 12:00\nA brief introduction to Integration\nWill\n\n\n\n\nBefore the next class:\nI. Please study the contents and work through all the code within the following lessons:\n\nRunning CCA integration and complex integration tasks\n\n\nClick here for a preview of this lesson\n\nIn class, we described the theory of integration and in what situations we would implement it. In this lesson you will: - Run the code to implement CCA integration  - Evaluate the effect of integration on the UMAP  - Learn about methods for complex integration tasks (Harmonizing samples) \n\nClustering\n\n\nClick here for a preview of this lesson\n\nFrom the UMAP visualization of our data we can see that the cells are positioned into groups. Our next task is to isolate clusters of cells that are most similar to one another based on gene expression. In this lesson you will: - Learn the theory behind clustering and how it is performed in Seurat - Cluster cells and visualize them on the UMAP\n\nClustering quality control\n\n\nClick here for a preview of this lesson\n\nAfter separating cells into clusters, it is crtical to evaluate whether they are biologically meaningful or not. At this point we can also decide if we need to re-cluster and/or potentialy go back to a previous QC step. In this lesson you will: - Check to see that clusters are not influenced by uninteresting sources of variation - Check to see whether the major principal components are driving the different clusters - Explore the cell type identities by looking at the expression for known markers across the clusters.\n\nSeurat Cheatsheet\n\n\nClick here for a preview of this lesson\n\nAt this point, we have populated our seurat object with many different pieces of information. Knowing how to access different values will allow you to interact more efficiently with your dataset. In this lesson you will: - Explore the different parts of a seurat object. - Use the built-in functions from the Seurat package for visualizations and grabbing data.\n\n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\nQuestions?\n\nIf you get stuck due to an error while runnning code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-3",
    "href": "lessons/schedule.html#day-3",
    "title": "",
    "section": "Day 3",
    "text": "Day 3\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n9:30 - 10:00\nSelf-learning lessons discussion\nAll\n\n\n10:00 - 11:00\nMarker identification\nNoor\n\n\n11:00 - 11:10\nBreak\n\n\n\n11:10 - 11:30\nWorkflow summary\nWill\n\n\n11:30 - 11:45\nOverview and Final Q & A\nAll\n\n\n11:45- 12:00\nWrap up\nWill"
  },
  {
    "objectID": "lessons/schedule.html#answer-keys",
    "href": "lessons/schedule.html#answer-keys",
    "title": "",
    "section": "Answer Keys",
    "text": "Answer Keys\n\nAnswer key - assignment #1\nAnswer key - assignment #2"
  },
  {
    "objectID": "lessons/schedule.html#downstream-analyses",
    "href": "lessons/schedule.html#downstream-analyses",
    "title": "",
    "section": "Downstream analyses",
    "text": "Downstream analyses\n\nDifferential expression between conditions"
  },
  {
    "objectID": "lessons/schedule.html#resources",
    "href": "lessons/schedule.html#resources",
    "title": "",
    "section": "Resources",
    "text": "Resources\nWe have covered the analysis steps in quite a bit of detail for scRNA-seq exploration of cellular heterogeneity using the Seurat package. For more information on topics covered, we encourage you to take a look at the following resources:\n\nSeurat-focused\n\nSeurat vignettes\nSeurat cheatsheet\nSatija Lab: Single Cell Genomics Day\nAdditional information about cell cycle scoring\nA nice explanation on CCA and cell label transfer in Seurat\n\n\n\nScaling up: scRNA-seq analysis on HPC\n\nUsing RStudio on O2\n\nHMSRC wiki page\nHBC RStudio on O2 tutorial\n\n\n\n\nCell type annotation\n\nDatabases with markers for manual annotation\n\nCellMarker 2.0\nCell type signature gene sets from MSigDb\nCELL x GENE from CZI\n\nReference-based automated celltype annotation\n\nAzimuth\nCelltypist\n\n\n\n\nHighlighted papers\n\n“Sampling time-dependent artifacts in single-cell genomics studies.” Massoni-Badosa et al. 2019\n“Dissociation of solid tumor tissues with cold active protease for single-cell RNA-seq minimizes conserved collagenase-associated stress responses.” O’Flanagan et al. 2020\n“Systematic assessment of tissue dissociation and storage biases in single-cell and single-nucleus RNA-seq workflows.” Denisenko et al. 2020\n“Confronting false discoveries in single-cell differential expression”, Nature Communications 2021\nSingle-nucleus and single-cell transcriptomes compared in matched cortical cell types\nA single-cell and single-nucleus RNA-Seq toolbox for fresh and frozen human tumors\nLigand-receptor analysis with CellphoneDB\nBest practices for single-cell analysis across modalities\n\n\n\nOther online scRNA-seq courses:\n\nOSCA with Bioconductor\nDFCI/Shirley Liu\nWellcome Sanger Institute/Hemmberg Lab\nISCB Workshop\nBroad workshop\nSciLifeLab workshop"
  }
]